我想说一说我的一些总结和思考。

- 不变 (Invariance)
- 协变 (Covariance)
- 逆变 (Contravariance)
- 双变 (Bivariance)

这里所谓的“变”(variance)是什么呢？假设有一个类型 P 以及它的一个子类型 C（我们说一个类型是另一个类型的子类型的时候，实际上表现为这个子类型可以直接赋值给父类，而赋值也包括传参这种情况），我们可以用符号表示这种关系： `C <: P`。

接下来我们用 P 和 C 构造两种新的类型 `Type<P>` 和 `Type<C>`，那么有以下几种情况：
如果 `Type<C> <: Type<P>`，我们说这是协变，就是说原来的 `C <: P` 关系被保持住了，是正向的。
如果 `Type<P> <: Type<C>`，我们说这是逆变，就是说原来的 `C <: P` 关系被反转了，是逆向的。
如果 `Type<C> <: Type<P> && Type<P> <: Type<C>`，我们说这是双变，正向和逆向都可以。
如果 `Type<C>` 和 `Type<P>` 没有任何关系了（就是说谁也不是谁的子类），我们说原来的 `C <: P` 被完全忽略了，所以这是不变。

在 Typescript 中，我们只有三种：协变、逆变和双变。在不开启 `strict` 模式的情况下，函数和方法都是双变的，而开启 `strict` 后，函数就是逆变的，方法还依然是双变的。其他情况下，比如数组、构造器等情况一般都是协变的。

######  数组
一般情况下数组应该是不变的。假设 Cat 是 Animal 的子类， 那么 Cat[] 和 Animal[] 应该作何考量呢？我们分别来考虑协变和逆变的情况。
如果是协变的，那么 Cat[] 可以当作 Animal[] 使用（也就是说，Cat[] 可以赋值给 Animal[] 或者可以传参给期望 Animal[] 的地方），那么这时候我往 Animal[] 里添加一个 Dog，这就改变了原来的 Cat[]，那我们如果再使用原来的 Cat[] 的时候，里面可能混杂了别的动物比如 Dog，我们认为这是不稳定的。
如果是逆变的，那么 Animal[] 可以当作 Cat[] 使用，这也是不行的，Animal[] 里可能有 Dog，如果在一个 Dog 上调用 Cat 才拥有的方法，就会出错。
所以我们可以看出，如果数组是协变的，就不能容许数组的写操作，如果数组是逆变的，就不能容许数组的读操作。
那么在 Typescript 中呢？Typescript 的选择其实上边已经说过了，数组的方法都是双变的，数组本身是协变的，这就能够保证大多数情况下类型系统的稳定。

###### 函数
先说结论，函数是有两个位置的考量的，一个是参数位置，一个是返回值的位置，在参数位置我们说函数是逆变的，在返回值的位置我们说函数是协变的。

我们来以一个特别的角度来理解一下这种行为。其实这很像是生活中的供需关系。让我们来举个例子，有如下函数：
```ts
let a : (x: Animal) => void
let b : (x: Cat) => void
```
我们把 b 赋值给 a（即 `a = b`），那么我们调用 a 的时候有可能传入一个 Dog，而函数 b 中有可能用到 Cat 专有的方法，所以这种情况下，我们说这是不稳定的。这种情况下， b 的参数位置是需求方，a 的参数位置是供给方，b 需求的是一个 Cat，而 a 供给的是一个 Animal，显然不能满足要求。
而如果我们把 a 赋值给 b，就是安全的。这种情况下，b 的参数位置是供给方，a 的参数位置就是需求方。b 供给的是一个 Cat，a 需求的是一个 Animal，这是符合要求的。

以上。
